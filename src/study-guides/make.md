---
title: 'GNU Make'
---

# GNU Make

[[toc]]

# What is Make?

Make is a tool used for triggering actions based on the tracking of files, traditionally in a C/C++ project.

A `makefile` contains the *rules*, **prerequisites**, **targets** and **commands** used in a project. By defining the targets to be generated, and that targets prerequisites, Make can determine whether changes to the source files warrant a revision to the target file. Make can be used to manage dependencies - if files haven't changed since the last execution of a `make` command, repeating the command will have no effect.

# Make Syntax

## Rules

``` make
target: prequisite
    command
```

The functional parts of a `makefile` are composed of block like this, called a **rule**. The rule defines the files, or **prerequisites** that are required to exist before the **command** contained in the rule is run. The result of a rule usually generates a **target** file.

### Prerequisites

### Targets

### PHONY

### Commands

### Tabs vs. Spaces

Unlike other languages, Make is not agnostic about tabs and spaces. Each command line must begin with a tab, and not spaces. 

## Variables

### ifdef

### ifeq

## Functions

### String Substitution

``` make
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)
DEPS := $(OBJS:.o=.d)
```

# Compiling

## Compile Commands

The `CC` compiler variable and `cc` command line variable is available to Mac/Linux users and points to the default C compiler. This can be made use of in Makefiles to easily call a compile command that should be okay on all systems.

``` make
$(CC) file1.c
```

This will generate a default `a.out` file as its ouput. While this can be executed `./a.out`, it can be called something more descriptive or memorable using the `-o` output flag.

``` make
$(CC) file1.c -o make_test
```

Includes can also be passed to this command using the `-I` flag. By default, the compiler will include the current directory it's invoked in, as well as the system header directory. The default directories can be shown with the `cpp -v` command.

``` make
$(CC) file1.c -I include/ -o make_test
```

## Object Files

Creating the binary output file includes the intermediary step of taking the **object files** generated by the compiler, and linking them to addresses in memory to create a program. The intermediary object files can be generated as the primary output in a multi-step Make process using the `-c` flag.

``` make
cc -c file1.c
```

This will result in a `file1.o` output. The functions and variables invoked in `file1` will be present in the object file, but the addresses will be temporary stubs with no set value. 

## **Linking**

Linkers combine object files, and libraries to create either object files, executables, or libraries. The default linker `ld`  for `gcc` and `clang` can be invoked for both C and C++, and outputs referenced the same was the compiler.

``` make
ld file1.o -o test_program
```

The compiler can also be used to invoke the `ld` linker:

``` make
cc file1.o -o test_program
```

## Linking Libraries

When linking against libraries, the `ld` linker can be invoked with the `-l` flag, followed by the name of the library on the compilers library path:

``` make
ld file1.o -lc -o test_program
```

In this case, `libc` was invoked by using the name of the library (all libraries begin with the `lib` prefix, so this can be ignored).

When the library is located in another directory, the `-L` flag cna used to specify:

``` make
ld file1.o -L/home/lib/ -lcustom test_program
```

To find which directories are being searched for libraries:
g
``` make
cc -print-search-dirs
```

A linker script can be passed as well, using the `-T` flag.

For debugging purposes, a `.map` file can be generated with all functions, variables, library imports, and their memory addresses and size.

``` make
cc file1.o -Wl,-map,program.map -o test_program
# or
ld file1.o -map program.map -o test_program
```

### Static Libraries

Denoted by the `.a` file extension, static libraries are files that contain functions that can be used by many applications. Within an application, linking a static library will copy the entire content of the library to the program.

### Dynamic Libraries

Denoted by the `.dll`, `.so`, or `.dylib` file extensions, dynamic libraries are referenced by the program that it is linked to, rather than copying the entire contents of the library. Dynamic libraries are referenced using a program called the **loader**, which reads the library contents and stores the machine code for the required functions into memory.

### Creating Static Libraries

Static libraries are creating using a program called an Archiver, `ar`. The benefits of compiling static libraries rather than dynamic libaries, are it can keep source code hidden, decrease coupling within the system, and reduce compilation times for files that aren't change often.

The syntax of the archiver command are as follows:

``` make
ar rcs library.a file1.o file2.o ...
```

The `rcs` refers to the flags `r`, which overwrites symbols into the archive, `c` which creates the archive, and `s` which writes an index. These flags can be passed in most cases and represents a catch-all command which should suit most use-cases.

### Creating Dynamic Libraries

Dynamic libaries must be created using the compiler, and are invoked using the `-fPIC` flag, as well as the `-shared` flag. The `-f` flag is followed by `PIC` for Position Independent Code, which allows the code to be references from other memory addresses.

```make
cc -fPIC -c file`.c -o test_program.o
cc -shared test_program.o -o libcustom.dylib
```

The `dylib` file extension for MacOS will be `dll` for Windows, and `so` for Linux.

Libraries which aren't found in the default paths will need to have their locations set as the `LD_LIBRARY_PATH` variable.

``` make
LD_LIBRARY_PATH=./libraries
```